#!/bin/env python

import os
import re
import sys
import json
import subprocess

input_name = sys.argv[1]
output_name = input_name.replace("report", "result")
os.makedirs(os.path.dirname(output_name), exist_ok=True)

if os.path.exists(output_name):
  exit(0)

def parentsrc(folder):
  with open(os.path.join("wine", folder, "Makefile.in"), "r") as make:
    for line in make.read().splitlines():
      if line.startswith('PARENTSRC'):
        return os.path.join(folder, re.split(r' +', line)[2])
  return folder

def winesrc(folder, source):
    if os.path.exists(os.path.join("wine", folder, source)):
      return os.path.join(folder, source)
    return os.path.join(parentsrc(folder), source)

def parse_report(name, file):
  info = {"name": name, "tests": {}, "failures": {}, "build-info": {}, "system-info": {}, "dlls-info": {}}

  def add_failure(line, match):
      failures.append(line)
      num = match.group('num')
      source = winesrc(testdir, match.group('source'))
      ranges[source] = ranges.get(source, set())
      ranges[source].add(f"-L{num},+1")

  for line in file.read().splitlines():
    decoded = line.decode("utf-8", errors="ignore")

    if match := re.match(r"^Tests from build (?P<build>[0-9a-f]+)", decoded):
      info["build"] = build = match.group('build')
    elif re.match(r"^Build info:", decoded):
      key = "build-info"
    elif re.match(r"^Operating system version:", decoded):
      key = "system-info"
    elif re.match(r"^Dll info:", decoded):
      key = "dlls-info"
    elif match := re.match(r"^    (?P<key>[^=]+)=(?P<value>.*)$", decoded):
      info[key][match.group('key')] = match.group('value')
    elif match := re.match(r"^(?P<testcase>[^:]+:[^:]+) start (?P<testdir>.*/tests)/.*\.c", decoded):
      test = match.group('testcase')
      info["tests"][test] = {"time": 0, "status": 0, "todo": 0, "fail": 0, "skip": 0, "flaky": 0, "crash": 0}

      ranges = {}
      origins = {}
      failures = []
      testdir = match.group('testdir')
    elif re.match(r"^(?P<source>[^:]+\.c):(?P<num>\d+):.* Test marked todo: ", decoded):
      info["tests"][test]["todo"] += 1
    elif match := re.match(r"^(?P<source>[^:]+\.c):(?P<num>\d+):.* Tests skipped: ", decoded):
      info["tests"][test]["skip"] += 1
    elif match := re.match(r"^(?P<source>[^:]+\.c):(?P<num>\d+):.* Test marked flaky: ", decoded):
      info["tests"][test]["flaky"] += 1
      add_failure(decoded, match)
    elif match := re.match(r"^(?P<source>[^:]+\.c):(?P<num>\d+):.* (Test succeeded inside flaky todo block: |Test succeeded inside todo block: |Test failed: )", decoded):
      info["tests"][test]["fail"] += 1
      add_failure(decoded, match)
    elif match := re.match(r"^(?P<source>[^:]+\.c):(?P<num>\d+):.* this is the last test seen", decoded):
      info["tests"][test]["crash"] = 1
    elif match := re.match(r"^(?P<source>[^:]+\.c):(?P<num>\d+):.* unhandled exception", decoded):
      info["tests"][test]["crash"] = 1
    elif match := re.match(r"^[^:]+:[^:]+:.* (?P<total>\d+) tests executed", decoded):
      info["tests"][test]["total"] = int(match.group('total'))
    elif match := re.match(r"^[^:]+:[^:]+:.* done \((?P<status>-?\d+)\) in (?P<seconds>\d+)s", decoded):
      info["tests"][test]["status"] = int(match.group('status'))
      info["tests"][test]["time"] = int(match.group('seconds'))

      for file in ranges:
        blames = subprocess.check_output(['git', '-C', 'wine', 'blame', build, '--no-progress', '-flnsw'] + list(ranges[file]) + [file], encoding='utf-8')
        for blame in blames.splitlines():
          rev, orig_file, orig_num, num, _ = re.split(r'[ )]+', blame, maxsplit=4)
          test = f"{os.path.basename(file)}:{num}"
          origins[test] = f"{orig_file}:{orig_num} @ {rev}"

      for line in failures:
        file, num, message = line.split(':', 2)
        origin = origins[':'.join([file, num])]

        info["failures"][origin] = info["failures"].get(origin, [])
        info["failures"][origin].append(testdir + '/' + line)

  return info

with open(input_name, "rb") as input, open(output_name, "w") as output:
  info = parse_report(os.path.basename(input_name).split('.report.')[0], input)
  output.write(json.dumps(info, indent=2))

print(input_name, 'done')
